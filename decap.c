/*
 * Copyright (c) 2024 FDL(Future cryptography Design Lab.) Kookmin University
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "decap.h"

/**
 * @brief Check error vector's Hamming Weight is t.
 *
 * @param [in] err_vec Error vector.
 * @return True of False.
 */
int check_err_vec(IN const Word *err_vec)
{
    int count;

    for (int i = 0; i < PARAM_N_WORDS; i++)
    {
        Word tmp = err_vec[i];

        while (tmp)
        {
            count++;
            tmp &= tmp - 1;
        }
    }

    return (count == PARAM_T);
}

/**
 * @brief Decapsulation function.
 *
 * @param [out] key Output key to be recovered.
 * @param [in] sk Secret key.
 * @param [in] r_hat Vector r_hat generated by the encapsulation function.
 * @param [in] s_hat Vector s_hat generated by the encapsulation function.
 * @param [in] gf2m_tables GF(2^m) operation tables.
 */
void decap(OUT Word *key, IN const SecretKey *sk, IN const Word *r_hat, IN const Word *s_hat, IN const gf2m_tab *gf2m_tables)
{
    gf P[PARAM_N] = {0};
    gf P_inv[PARAM_N] = {0};
    Word e_hat[PARAM_N_WORDS] = {0};   // e_hat
    Word e_star[PARAM_N_WORDS] = {0};  // e_star
    Word e_tilde[PARAM_N_WORDS] = {0}; // e_tilde
    Word r_hat_p[SEED_WORDS] = {0};                   // r_hat_prime
    Word e_r_s[ROH_INPUT_WORDS] = {0};
    Word *e_tmp = NULL;

#if BENCH_MODE == ON
    uint64_t cyc_s;
    uint64_t cyc_e;
    cyc_s = cycle_read();
#endif

    /* Decrypt */
    decrypt(e_hat, sk, s_hat, gf2m_tables);

#if BENCH_MODE == ON
    cyc_e = cycle_read();
    paloma_cycle_result.decrypt = cyc_e - cyc_s;
#endif

    /* Check the recovered error vector is valid */
    if (!check_err_vec(e_hat))
    {
        puts("invalid error vector: error vector does not have t error.");
        exit(1);
    }

    /* Generate permutation matrix */
    gen_rand_perm_mat(P, P_inv, PARAM_N, r_hat);

    /* e_star = P^{âˆ’1} * e_hat */
    memset(e_star, 0, (sizeof(Word)) * PARAM_N_WORDS);
    for (size_t i = 0; i < PARAM_N; i++)
    {
        Word bit = ((e_hat[P_inv[i] / WORD_BITS] >> (P_inv[i] % WORD_BITS)) & 1);
        e_star[i / WORD_BITS] ^= bit << (i % WORD_BITS);
    }

    /* r_hat_prime = RO_G(e_star) */
    rand_oracle(r_hat_p, e_star, PARAM_N, 1);

    /* e_tilde = GenErrVec(r) */
    gen_rand_err_vec(e_tilde, sk->r);

    /* Use e_star if r_hat = r_hat_prime */
    e_tmp = e_star;

    /* Use e_tilde if r_hat != r_hat_prime */
    for (int i = 0; i < 4; i++)
        if (r_hat[i] != r_hat_p[i])
            e_tmp = e_tilde;

    /* key = RO_H(e_star(or e_tilde) || r_hat || s_hat) */
    memcpy(e_r_s, e_tmp, sizeof(Word) * PARAM_N_WORDS);
    memcpy(e_r_s + PARAM_N_WORDS, r_hat, sizeof(Word) * SEED_WORDS);
    memcpy(e_r_s + PARAM_N_WORDS + SEED_WORDS, s_hat, sizeof(Word) * SYND_WORDS);

    rand_oracle(key, e_r_s, ROH_INPUT_BITS, 2);
}
